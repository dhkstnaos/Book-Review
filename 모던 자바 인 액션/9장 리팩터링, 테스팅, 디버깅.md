# 9장 리팩터링, 테스팅, 디버깅
이 장에서는 기존 코드를 어떻게 람다를 이용해 가독성과 유연성을 높이는지 설명한다.
추가적으로 람다 표현식으로 전략, 템플릿 메서드, 옵저머, 의무 체인, 팩토리 등 다양한 객체지향 디자인 패턴을 어떻게
간소화할 수 있는지 살펴보자. 마지막으로 테스트 및 디버깅 방법에 대해서도 설명한다.

## 9.1 가독성과 유연성을 개선하는 리팩토링
### 9.1.1 코드 가독성을 개선
코드 가독성이 좋다는 것은 어떤 코드를 다른 사람도 쉽게 이해할 수 있음을 뜻한다.
이를 높이기 위해선 코드 문서화를 잘하고, 표준 코딩 규칙을 준수해야 한다.
자바8의 새 기능을 통해 가독성을 높일 수 있고, 간결하고 이해하기 쉽게 만들 수 있다.
메서드 참조와 스트림을 통해 의도를 정확히 전달할 수 있다.

### 9.1.2 익명 -> 람다로 리팩토링하기
하나의 추상 메서드를 구현하는 익명 클래스는 람다 표현식으로 전부 리팩터링할 수 있다.  
모든 익명 클래스를 변환할 수 없다.
1. 익명 클래스에서 사용하는 this, super는 람다에서 다른 의미를 갖는다. 익명 클래스에선 this는 익명 클래스 자신을 가리키나 람다에선 람다를 감싸는 클래스를 가리킨다.
2. 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 잇다. 그러나 람다로는 변수를 가릴 수 없다.
````java
Runnable r1 = new Runnable() {
      @Override
      public void run() {
        System.out.println("hello");
      }
};

//람다로 개선
Runnable r2 = () -> System.out.println("hello");
````

### 9.1.3 람다->메서드 참조로 리팩토링하기
람다 대신 메서드 참조를 이용해서 가독성을 높이고, 의도를 명확하게 알릴 수 있다.
```java
private static Map<Dish.Type, Map<CaloricLevel, List<Dish>>> groupDishedByTypeAndCaloricLevel() {
    return menu.stream().collect(
            groupingBy(Dish::getType,
                groupingBy(dish -> classifyingCaloricLevel(dish.getCalories()))
            ));
}
```

### 9.1.4 명령형 데이터를 스트림으로 리팩토링하기
반복자를 이용한 컬렉션 처리를 스트림으로 바꿔야 한다. 스트림은 쇼트서킷과 게으름이라는 강력한 최적화뿐 아니라
멀티코어 아키텍쳐를 활용할 수 있는 지름길을 제공한다. 또한 병렬 처리도 쉽게 할 수 있도록 제공한다.

## 9.2 람다로 객체지향 디자인 패턴 리팩토링하기
언어에 새로운 기능이 추가되면 기존 코드 패턴, 관용 코드의 인기가 식기도 한다. 디자인 패턴은 공통적인 문제를
해결할 때 재사용할 수 있는 검증된 청사진을 제공한다. 디자인 패턴에 람다 표현식이 더해진다면 문제를 더 쉽고 간단하게
해결할 수 있다.
이번 장에선 5가지 패턴을 살펴본다.
1. 전략
2. 템플릿 메서드
3. 옵저버
4. 의무 체인
5. 팩토리

### 9.2.1 전략
전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 적절한 알고리즘을 선택하는 기법이다.
다음에서 Validator는 클라이언트를 담당하고, ValidatorStrategy는 전략을 담당하는 인터페이스이며,
IsAllLowerCase, IsNumeric는 고수준 구현체를 담당한다.  
책에선 구식 버전 대신 람다를 활용한 코드를 사용하라는 것을 알 수 있다.
```java
interface ValidationStrategy {
    boolean execute(String s);
  }

  static private class IsAllLowerCase implements ValidationStrategy {

    @Override
    public boolean execute(String s) {
      return s.matches("[a-z]+");
    }

  }

  static private class IsNumeric implements ValidationStrategy {

    @Override
    public boolean execute(String s) {
      return s.matches("\\d+");
    }

  }

  static private class Validator {

    private final ValidationStrategy strategy;

    public Validator(ValidationStrategy v) {
      strategy = v;
    }

    public boolean validate(String s) {
      return strategy.execute(s);
    }

  }
}

//old
Validator v1 = new Validator(new IsNumeric());
System.out.println(v1.validate("aaaa"));

// with lambdas
Validator v3 = new Validator((String s) -> s.matches("\\d+"));
System.out.println(v3.validate("aaaa"));
```

### 9.2.2 템플릿 메서드
알고리즘 개요를 제시한 다음에 알고리즘 일부를 고칠 수 있는 유연함을 제공해야 할때 템플릿 메서드 디자인 패턴을 사용한다.
Consumer를 활용해서 다양한 컴포넌트를 추가할 수도 있다.람다를 이용하면 자잘한 부수적인 코드도 제거할 수 있다.
```java
abstract class OnlineBanking {
  public void processCustomer(int id) {
    Customer c = Database.getCustomerWithId(id);
    makeCustomerHappy(c);
  }
  abstract void makeCustomerHappy(Customer c);
}
```

람다 표현식 사용
```java
public class OnlineBankingLambda {

  public static void main(String[] args) {
    new OnlineBankingLambda().processCustomer(1337, (Customer c) -> System.out.println("Hello!"));
  }

  public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) {
    Customer c = Database.getCustomerWithId(id);
    makeCustomerHappy.accept(c);
  }
}
```

### 9.2.3 옵저버
어떤 이벤트가 발생했을때 한 객체가 다른 객체에 자동으로 알림을 보내야 하는 상황에서 옵저버 패턴을 사용한다.
