## 2장 객체 생성과 파괴
 

생성자 대신 정적 팩터리 메소드 패턴을 고려해라
정적 팩토리 메서드란 - 객체 생성을 하는 메서드를 의미합니다.


```
public class Level {
  public static Level of(int score) {
    if (score < 50) {
      return new Basic();
    } else if (score < 80) {
      return new Intermediate();
    } else {
      return new Advanced();
    }
  }
}
```

### 장점
* 이름을 가질 수 있다.
* 호출될 때마다 인스턴스를 새로 생성하지 않을 수도 있다.
* 반환 타입의 하위 타입 객체를 반환할 수도 있다.
* 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수도 있다.
* 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
### 단점
* 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들수 없다.
* 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 생성자처럼 명확히 드러나지 않는다.
 

### 정적 팩토리 메서드 네이밍 방법
from: 한 개의 매개 변수로 객체 생성
of: 여러 개의 매개 변수로 객체 생성
getInstance: 인스턴스를 반환
newInstance: 새 인스턴스를 반환
 

### 생성자에 매개변수가 많다면 빌더를 고려하라  

```
public class NutritionFacts {
	private final int servingSize;
	private final int servings;
	private final int calories;
	private final int fat;
	private final int sodium;
	private final int carbohydrate;

	public static class Builder {
		// 필수 매개변수
		private final int servingSize;
		private final int servings;

		// 선택 매개변수
		private int calories = 0;
		private int fat = 0;
		private int carbohydrate = 0;
		private int sodium = 0;

		public Builder(int servingSize, int servings) {
			this.servingSize = servingSize;
			this.servings = servings;
		}
		public Builder calories(int val) {
			calories = val;
			return this;
		}
		public Builder fat(int val) {
			fat = val;
			return this;
		}
		public Builder carbohydrate(int val) {
			carbohydrate = val;
			return this;
		}
		public Builder sodium(int val) {
			sodium = val;
			return this;
		}
		public NutritionFacts build() {
			return new NutritionFacts(this);
		}
	}
	private NutritionFacts(Builder builder) {
		servingSize = builder.servingSize;
		servings = builder.servings;
		calories = builder.calories;
		fat = builder.fat;
		sodium = builder.sodium;
		carbohydrate = builder.carbohydrate;
	}
	public static void main(String[] args) {
		NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
				.calories(100).sodium(35).carbohydrate(27).build();
	}
}
// cocaCola (240,8,100,null,35,27)
```

유저는 필수 매개변수만으로 생성자, 정적 팩터리 메서드를 호출해 빌더 객체를 얻고 빌더 객체가 세터를 사용해 선택 매개변수를 설정한다.

### 장점
* 빌더 패턴은 쓰기 쉽고 읽기 쉽다.
* 계층 설계 클래스와 쓰기 좋다.
### 단점
* 매개변수 3개 이하는 성능 상 이점이 없다.
 

### private 생성자나 열거 타입으로 싱글턴임을 보장하라
싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스

그러나 클래스를 싱글턴으로 만들면 클라이언트 테스트가 어려워질수 있다.

### 싱글턴 생성 방식
공통적으로 생성자는 private, public static 멤버를 만든다.

1. final 방식

public static final 방식의 장점은 싱글턴임에도 명백히 api 드러난다. 또한 간결함이 장점이다.

```
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();

	private Elvis() {
	}
	public void leaveTheBuilding() {
		System.out.println("Whoa baby, I'm outta here!");
	}
	public static void main(String[] args) {
		Elvis elvis = Elvis.INSTANCE;
		elvis.leaveTheBuilding();
	}
}
```

2. 정적 팩토리 메소드 제공

api를 건드리지 않고도 싱글턴이지 않게 바꿀 수 있다.

원하면 제네릭 싱글 팩토리로 만들 수 있다. (30번 참조)

정적 팩터리 메서드 참조를 공급자로 사용할 수 있다. Elvis::getInstance를 Supplier<Elvis>로 사용 방식(43번, 44번)

  ```
  public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {
    }
    public static Elvis getInstance() {
      return INSTANCE;
    }
    public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
    }
    public static void main(String[] args) {
      Elvis elvis = Elvis.getInstance();
      elvis.leaveTheBuilding();
    }
  }
  ```
1,2번 방식으로 만든 싱글턴을 직렬화할 때 단순 직렬화 구현으로 되지 않는다. readResolve 메소드를 제공하지 않으면 역직렬화 시 새 인스턴스가 만들어 지게 된다.

  ```
  public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {
    }
    public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
    }
    private Object readResolve() {
      return INSTANCE;
    }
  }
  ```

3. 원소가 하나인 열거 타입 선언

  ```
  public enum Elvis {
    INSTANCE;
    public void leaveTheBuilding() {
      System.out.println("Whoa baby, I'm outta here!");
    }
    public static void main(String[] args) {
      Elvis elvis = Elvis.INSTANCE;
      elvis.leaveTheBuilding();
    }
  }
  ```
1,2번보다 직렬화가 쉽고 간결하다. 대부분의 상황에서 원소가 하나인 열거 타입 싱글턴을 만드는 것이 좋은 방법. 그러나 다른 class를 상속해야 한다면 사용할 수 없다

 
### 인스터스화를 막을땐 private 생성자 사용하라
추상 클래스 만드는 것으로 인스턴스화를 막을 수 없다. 하위 클래스를 만들어 인스턴스화 할 수 있다. (19번)

인스턴스화를 막을때는 컴파일러가 기본 생성자를 만드는 경우는 명시 생서자가 없을 경우뿐이니 private 생성자를 추가하면 클래스의 인스턴스화를 방지할 수 있다. 
private이니 클래스 바깥에서 접근할 수 없고, 상속이 불가능하다.

```
public class UtilityClass {
	private UtilityClass() {
		throw new AssertionError();
	}
}
```

### 자원을 명시하지 않고 의존 객체 주입을 사용하라
의존 객체 주입 방식

클래스가 내부적으로 하나 이상의 자원에 의존하고 클래스에 영향을 준다면 의존 객체 주입으로 유연성 재사용성, 테스트 용이성을 개선시켜준다.

1. 생성자 주입
    ```
    public class MemberServiceImpl implements MemberService{

        private final MemberRepository memberRepository;

        @Autowired
        public OrderServiceImpl(MemberRepository memberRepository){
            this.memberRepository = memberRepository;
        }
    }
    ```
2. setter 주입
    ```
    public class MemberServiceImpl implements MemberService{
        private MemberRepository memberRepository;
        @Autowired
        public void setMemberRepository(MemberRepository memberRepository){
            this.memberRepository = memberRepository;
        }
    }
    ```

### 불필요한 객체 생성을 피하라
같은 기능의 객체는 매번 생성하지 않고 재사용을 하는 편이 낫다.

안 좋은 예시 - 실행 때마다 String 인스턴스를 계속 생성한다.

String s=new String("bikini");
개선 버전

String s="bikini";
생성자 대신 정적 팩터리 메서드(1. 생성자 대신 정적 팩토리 메서드를 고려하라 )를 사용하면 재사용성을 높일 수 있다.

```
public class RomanNumerals {
    // Performance can be greatly improved! (Page 22)
    static boolean isRomanNumeralSlow(String s) {
        return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
                + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }
    private static final Pattern ROMAN = Pattern.compile(
            "^(?=.)M*(C[MD]|D?C{0,3})"
                    + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

    static boolean isRomanNumeralFast(String s) {
        return ROMAN.matcher(s).matches();
    }

    public static void main(String[] args) {
        int numSets = Integer.parseInt(args[0]);
        int numReps = Integer.parseInt(args[1]);
        boolean b = false;

        for (int i = 0; i < numSets; i++) {
            long start = System.nanoTime();
            for (int j = 0; j < numReps; j++) {
                b ^= isRomanNumeralSlow("MCMLXXVI");  // Change Slow to Fast to see performance difference
            }
            long end = System.nanoTime();
            System.out.println(((end - start) / (1_000. * numReps)) + " μs.");
        }

        // Prevents VM from optimizing away everything.
        if (!b)
            System.out.println();
    }
}
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++)
        sum += i;
    return sum;
}
```
                                           
Long을 쓰지 않고 long 타입을 써서 오토 박싱을 막는다.

 

### 다 쓴 객체 참조를 해제하라
pop 메서드 작동 시 다 쓴 배열에서 메모리 누수가 발생한다. elements[size] = null;

캐시 또한 메모리 누수를 일으키는 주범이다.

또한 리스너 혹은 콜백을 부르는 것이다. 콜백을 등록하고 해지하지 않으면 쌓인다. 이럴 때 콜백을 약한 참조로 저장하면 된다. 예를 들어 weakHashMap

```                                           
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;
    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }

//    // Corrected version of pop method (Page 27)
//    public Object pop() {
//        if (size == 0)
//            throw new EmptyStackException();
//        Object result = elements[--size];
//        elements[size] = null; // Eliminate obsolete reference
//        return result;
//    }

    public static void main(String[] args) {
        Stack stack = new Stack();
        for (String arg : args)
            stack.push(arg);

        while (true)
            System.err.println(stack.pop());
    }
}
``` 

### try-finally보다는 try-with-resources를 사용하라
자원의 반환을 보장하기 위해 try-finally가 많이 쓰였다.
                                           
```
public class TopLine {
    // try-finally - No longer the best way to close resources! (page 34)
    static String firstLineOfFile(String path) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(path));
        try {
            return br.readLine();
        } finally {
            br.close();
        }
    }
    public static void main(String[] args) throws IOException {
        String path = args[0];
        System.out.println(firstLineOfFile(path));
    }
}
```                                           
그러나 자원 두 개 이상 사용 시 문제가 발생한다. 그렇기에 try-with-resources문을 사용한다.

코드가 짧아 간결하고 읽기 쉽고 문제 진단도 좋다

```                                           
public class TopLine {
    static String firstLineOfFile(String path) throws IOException {
        try (BufferedReader br = new BufferedReader(
                new FileReader(path))) {
            return br.readLine();
        }
}
/////////////////////////////////////////////////////////////////////////
public class TopLineWithDefault {
    // 캐치 문과 함께 사용
    static String firstLineOfFile(String path, String defaultVal) {
        try (BufferedReader br = new BufferedReader(
                new FileReader(path))) {
            return br.readLine();
        } catch (IOException e) {
            return defaultVal;
        }
    }
``` 

복수 자원 처리 함수

```                                           
import java.io.*;
public class Copy {
    private static final int BUFFER_SIZE = 8 * 1024;
    static void copy(String src, String dst) throws IOException {
        try (InputStream   in = new FileInputStream(src);
             OutputStream out = new FileOutputStream(dst)) {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        }
    }
    public static void main(String[] args) throws IOException {
        String src = args[0];
        String dst = args[1];
        copy(src, dst);
    }
}
```  
