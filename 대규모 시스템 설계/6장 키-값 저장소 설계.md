# 6장 키-값 저장소 설계
키-값 저장소는 비 관계형 데이터베이스이다. 고유 식별자 키를 가져야 한다. 키는 일반 텍스트일수도 있고, 해시 값일 수도
있다. 성능상의 이유로 키는 짧을수록 좋다.

이번 장에선 키-값 저장소를 설계해볼 것이다.

## 문제 이해 및 설계 범위 확정
* 키-값 쌍의 크기는 10KB
* 큰 데이터를 저장할 수 있어야 한다.
* 높은 가용성을 제공해야 한다.
* 높은 규모 확장성을 제공해야 한다.
* 데이터 일관성 수준은 조정이 가능해야 한다.
* 응답 지연 시간이 짧아야 한다.

### 단일 서버 키-값 저장소
한 대의 서버를 사용하는 키-값 저장소 설계는 쉽다. 키 값 쌍 전부를 메모리에 해시 테이블로 저장한다. 빠른 속도를
가지지만 모든 데이터를 메모리에 올릴 수는 없다. 문제 해결을 위한 해결책은 다음과 같다.
* 데이터 압축
* 자주 쓰는 데이터만 메모리에 두고 나머지는 디스크에 저장  

이렇게 설계해도 부족할 때가 있다.

### 분산 키-값 저장소
분산 키-값 저장소는 분산 해시 테이블이라고도 불린다. 분산 시스템 설계 시에는 CAP 정리를 잘 알아야 한다.

### CAP 정리
CAP는 데이터 일관성(Consistency), 가용성(Availability), 파티션 감내(Partition Tolerance)라는 세 요구 사항을 동시에 만족하는 사실상 불가능한
정리이다.

* 데이터 일관성: 분산 시스템에 접속해 어떤 노드에 접속해도 같은 데이터를 볼 수 있어야 한다.
* 가용성: 일부 노드에 장애가 있어도 응답을 받을 수 있어야 한다.
* 파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생함을 의미한다. 네트워크에 파티션이 발생해도 시스템이 계속해서 동작해야 한다.

키-값 저장소는 두 가지를 만족하느냐에 따라 분류할 수 있다.
* CP 시스템: 일관성과 파티션 감내를 지원, 가용성 희생
* AP 시스템: 가용성과 파티션 감내를 지원, 일관성 희생
* CA 시스템: 일관성과 가용성을 지원, 일반적으로 네트워크 장애는 피할 수 없으므로 존재할 수 없는 시스템이다.

일반적으로 은행권 시스템은 데이터 일관성을 중요시 여기기 때문에 가용성을 희생하는 CP 시스템을 이용한다.
가용성이 중요한 시스템에선 지속적으로 읽기 연산을 허용해야 하기에 AP 시스템을 이용한다.

### 시스템 컴포넌트
* 데이터 파티션
* 데이터 다중화(레플리케이션)
* 일관성
* 일관성 불일치 해소
* 장애 처리
* 시스템 아키텍처 다이어그램
* 쓰기 경로
* 읽기 경로

널리 사용되고 있는 키-값 저장소의 사례를 참고한다.

#### 데이터 파티션
대규모 어플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다. 가장 단순한 해결책은
작은 파티션으로 분할한뒤에 여러 서버에 분산 저장하는 것이다.

안정해시를 이용해 데이터를 파티션할때의 이점
* 규모 확장 자동화
* 다양성

#### 데이터 다중화
높은 가용성과 안정성 확보를 위해 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.
같은 데이터 센터에 있는 노드는 여러 이슈에 의해 같은 문제를 겪을 수 있다. 안정성을 담보하기 위해 데이터 사본은 다른 센터에
보관하고 센터는 고속 네트워크로 연결한다.

#### 데이터 일관성
여러 노드에 다중화된 데이터는 적절한 동기화가 이뤄져야 한다. 정족수 합의 프로토콜(?)을 이용하면 읽기 쓰기 연산에 일관성을
부여할 수 있다.  
N = 사본 개수
W = 쓰기 연산에 대한 정족수 -> W개의 서버로부터 쓰기 연산 성공 응답을 받아야 한다.
R = 읽기 연산에 대한 정족수 -> R개의 서버로부터 읽기 연산 성공 응답을 받아야 한다.

R=1, W=N: 빠른 읽기 연산에 최적화  
W=1, R=N: 빠른 쓰기 연산에 최적화  
W+R > N: 강한 일관성이 보장  
w+R <= N: 일관성 보장되지 않음  

요구되는 수준에 따라 조정하면 된다.

##### 일관성 모델
일관성 모델은 여러 종류가 있다.
* 강한 일관성: 모든 읽기 연산은 가장 최근 갱신 결과를 반환한다. -> 모든 사본에 쓰기 결과가 반영될 때까지 쓰기, 읽기를 금지하기에 고가용성 시스템에 적합하진 않다.
* 약한 일관성: 읽기 연산은 최근 갱신 결과를 반환하지 못할 수 있다.
* 최종 일관성: 약한 일관성의 한 형태로 갱신 결과가 결국 동기화되는 모델이다.

#### 비 일관성 해소 기법: 데이터 버저닝
데이터 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성이 높다. 버저닝은 데이터를 변경할때마다 해당 데이터의 새로운 버전을 만드는
것을 의미한다. 따라서 각 버전의 데이터는 변경 불가능하다.

#### 장애 처리
대규모 시스템에서는 흔한 문제이고 어떻게 처리하느냐는 굉장히 문제다. 우선 장애 감지 기법을 살피고, 해소 전략을 알아보자

##### 장애 감지
분산 시스템에서는 두 대 이상의 서버가 서버의 장애를 보고해야 장애 발생으로 간주한다. 모든 노드를 감시하는 것은 분명
비효율적인 일이다. 따라서 가십 프로토콜 같은 분산형 장애 감지를 채택하는 편이 낫다.

##### 일시적 장애 처리
장애 감지된 시스템은 가용성 보장을 위해 조치를 해야한다. 엄격한 일관성 보장을 위해서라면 쓰기,읽기를 금지시켜야 한다.
느슨한 정족수 방법은 가용성을 높일 수 있다. 장애인 서버를 제외하고 읽기, 쓰기를 수행할 건강한 서버를 고른다.
그 후에 해당 서버로 가는 요청을 다른 서버가 맡아서 처리한다. 해당 서버가 복구되었을때 일괄적으로 반영해
데이터 일관성을 보장한다. 이러한 방법을 임시 위탁이라고 부른다.

##### 영구 장애 처리
임시 위탁은 일시적인 처리 기법이다. 영구 노드 장애는 반-엔트로피 프로토콜을 구현해 사본을 동기화한다. 이것은
사본을 비교해 최신 버전으로 갱신하는 과정을 포함한다. 사본 간 일관성을 탐지하고 전송 데이터 양을 줄이기 위해
머클 트리라는 것을 사용한다. -> 효과적이면서 안전하게 검증할 수 있다.

### 시스템 아키텍쳐 다이어그램 주된 기능
* 클라이언트는 단순히 통신한다.
* 중재자는 클라이언트에게 키-값 저장소에 대한 프락시 역할을 하는 노드이다.
* 노드는 안정 해시의 해시 링 위에 분포한다.
* 노드가 자동 추가 삭제가 되도록 분산된다.
* SPOF(Single Point of Failure)같은 문제는 없다.

#### 쓰기 경로
특정 노드에 쓰기 요청이 전달되는 과정
1. 쓰기 요청이 커밋 로그 파일에 기록된다.
2. 데이터가 메모리 캐시에 기록된다.
3. 캐시가 가득차거나 임계치에 도달하면 SSTable이라는 디스크에 저장된다.

#### 읽기 경로
읽기 요청의 과정
1. 데이터가 메모리에 있는지 검사
2. 없으면 블룸 필터를 검사
3. 어떤 SSTable에 저장됐는지 알아낸다.
4. 데이터를 가져온다.
5. 결과 반환

### 요약

| 목표                  | 문제                  |
|---------------------|---------------------|
| 대규모 데이터 저장          | 안정 해시 사용 부하 분산      |
| 읽기 연산에 대한 높은 가용성 보장 | 여러 데이터 센터에 다중화      |
| 쓰기 연산에 대한 높은 가용성 보장 | 버저닝 및 벡터 시계로 충돌 해소  |
| 데이터 파이션             | 안정 해시               |
| 점진적 규모 확장성          | 안정 해시               |
| 조절 가능한 데이터 일관성      | 정족수 합의              |
| 일시적 장애 처리           | 느슨한 정족수 프로토콜, 임시 위탁 |
| 영구적 장애 처리           | 머클 트리               |