# 21장 소리치는 아키텍처
아키텍처는 시스템을 이야기해야 하며, 시스템에 적용된 프레임워크에 대해서 이야기 해선 안된다 .  
프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다.  

### 아키텍처의 목적
좋은 아키텍처는 유스케이스를 중심에 두기에 프레임워크나 외부 환경에 전혀 구애받지 않고, 유스케이스를 지원하는 구조를
문제 없이 기술할 수 있다.  

### 테스트하기 쉬운 아키텍처
아키텍처가 유스케이스를 최우선으로 한다면, 프레임워크에 구애받지 않고, 필요한 유스케이스 전부에 대해
단위 테스트를 할 수 있어야 한다. DB가 연결되어야만 테스트를 돌릴 수 있어도 안된다.  

# 22장 클린 아키텍처
### 관심사의 분리
아키텍처는 소프트웨어를 계층으로 분리함으로써 관심사를 분리한다.

**관심사를 분리함으로 생기는 장점**
* 프레임워크 독립성
* 테스트 용이성
* UI 독립성
* DB 독립성
* 외부 에이전시에 대한 독립성

> 의존성 규칙
> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

#### 엔티티
전사적인 핵심 업무 규칙을 캡슐화한다.  

#### 유스케이스
앱에 특화된 업무 규칙을 포함한다.  

#### 인터페이스 어댑터
어댑터는 유스케이스와 엔티티에게 가장 편리한 형식으로 변환한다.  

#### 프레임워크와 드라이브
프레임워크와 드라이버 계층은 가장 저수준 계층으로 모든 세부 사항이 위치하는 곳이다.  
우리는 이러한 것들을 외부로 위치시켜 애플리케이션의 변경을 최소화한다. 

# 23장 프레젠터와 험블 객체
### 험블 객체 패턴
디자인 패턴으로 테스트 하기 어려운 행위와 쉬운 행위를 단위 테스트하는 패턴이다.  
가장 본질적인 객체는 남기고, 테스트하기 어려운 행위는 험블 객체로 옮긴다.  

# 24장 부분적 경계
아키텍처 경계를 부분적으로 구현하는 간단한 방법 세 가지를 살펴본다.

### 마지막 단계를 건너뛰기
부분적 경계를 생성하는 방법 하나는 Boundary 인터페이스, Input과 Output을 위한 데이터 구조를 모두 
완성한 후, 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업을 수행만 한 뒤 단일 
컴포넌트에 그대로 모아만 두는 것이다.

이 방법은 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계가 필요하다. 하지만 다수의 컴포넌트를 관리하는 작업은 
하지 않아도 된다. 추적을 위한 버전 번호도 없으며, 배포 관리 부담도 없다.

### 일차원 경계
완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 
양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.

전통적인 전략(strategy) 패턴을 사용하여 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보할 수 있는 
구조를 만들 수는 있으나, 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면,
이러한 분리는 매우 빠르게 붕괴될 수 있다는 점 역시 분명하다.

### 퍼사드
이보다 훨씬 더 단순한 경계는 퍼사드(Facade) 패턴으로, 경계는 퍼사드 클래스로만 간단히 정의된다. 
퍼사드 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스
클래스로 호출을 전달한다. 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.  
